package main

import "fmt"

func main() {

	// if we compile using "go build -gcflags '-m' ./test/allocation/make-alloc/*.go"
	// we see that make do or not do allocat in head.

	// Example output:
	// go build -gcflags '-m' ./test/allocation/make-alloc/*.go
	// # command-line-arguments
	// test/allocation/make-alloc/main.go:13:13: inlining call to fmt.Println
	// test/allocation/make-alloc/main.go:14:13: inlining call to fmt.Println
	// test/allocation/make-alloc/main.go:15:13: inlining call to fmt.Println
	// test/allocation/make-alloc/main.go:18:13: inlining call to fmt.Println
	// test/allocation/make-alloc/main.go:10:6: moved to heap: ar
	// test/allocation/make-alloc/main.go:13:17: len(ar) escapes to heap
	// test/allocation/make-alloc/main.go:13:13: []interface {} literal does not escape
	// test/allocation/make-alloc/main.go:14:13: sl escapes to heap
	// test/allocation/make-alloc/main.go:14:13: []interface {} literal does not escape
	// test/allocation/make-alloc/main.go:15:13: l escapes to heap
	// test/allocation/make-alloc/main.go:15:13: []interface {} literal does not escape
	// test/allocation/make-alloc/main.go:17:13: make([]byte, 15) does not escape
	// test/allocation/make-alloc/main.go:18:17: len(sl2) escapes to heap
	// test/allocation/make-alloc/main.go:18:13: []interface {} literal does not escape
	// <autogenerated>:1: .this does not escape

	var ar [15]byte
	sl := ar[:]
	l := len(sl)
	fmt.Println(len(ar))
	fmt.Println(sl)
	fmt.Println(l)

	sl2 := make([]byte, 15)
	// fmt.Println(sl2)
	fmt.Println(len(sl2))
}
